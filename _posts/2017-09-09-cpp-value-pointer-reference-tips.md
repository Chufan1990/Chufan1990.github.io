---
layout: post
title: C++ 值传递、指针传递、引用传递 
date: 2017-09-09
categories: blog
tags: [C++, cpp, value, pointer, referenece]
description: C++ value pointer reference
---

> 原文引用 [C++ 值传递、指针传递、引用传递详解](http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html)


**值传递**

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

**指针传递**

形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参背身进行操作。

**引用传递**

形参相当于实参的“别名”，对形参的操作其实就是对实参的操作。在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参的任何操作都影响了主调函数中的实参变量。

下面的代码对此做出了细致的解释（从实参、形参的内存中存放地址的角度说明了问题的本质）

```
#include <iostream>

using namespace std;

//值传递

void change1(int n)
{
	cout << "值传递--函数操作地址" << &n << endl;		//显示的是拷贝的地址而不是源地址
	n++;
}

//引用传递

void change2(int &n)
{
	cout << "引用传递--函数操作地址" << &n <<endl;
	n++;
}

//指针传递

void change3(int *n)
{
	cout << "指针传递--函数操作地址" << n << endl;
	*n = *n + 1;
}

int main()
{
	int n = 10;
	cout << "实参的地址" << &n << endl;

	change1(n);
	cout << "after change1() n = " << n <<endl;
	change2(n);
	cout << "after change2() n = " << n <<endl;
	change3(n);
	cout << "after change3() n = " << n <<endl;

	return 0;
}
```

运行结果如下，（不同的机器坑会有所差别）

![我也不知道啥名字.jpg](https://github.com/Chufan1990/Chufan1990.github.io/raw/master/img/2011120710381445.jpg)


可以看出，实参的地址为0x22ff44

采用值传递的时候，操作函数的地址是0x22ff20，并不是实参本身，所以对它进行操作并不能改变实参的值。

再看引用传递，操作地址也就是实参地操作地址，只是相当于实参的一个别名，对它的操作就是对实参的操作。

接下来是指针传递，也可发现操作地址是实参地址。

那么，引用传递和指针传递有什么区别吗？

**引用的规则**

1. 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）
2. 不能有**NULL**引用，引用必须与合法的储存单元关联（指针则可以是**NULL**）
3. 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）

**指针传递的实质**

指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理。即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点被调函数对形式参数的任何操作都会作为局部变量进行，不会影响主调函数的是参变量的值。（这里是在说实参指针本身的地址值不会变）

**指针传递和引用传递一般适用于：**

函数内部修改参数并希望改动影响调用者。对比指针/引用传递可以将改变由形参“传给”实参（实际上就是直接在实参的内存上修改，不像值传递将实参的值拷贝到另外的内存地址中才修改）。

另一种用法：当一个函数实际需要返回多个值，而只能显式返回一个值时，可以将另外需要返回的变量以指针/引用传递给函数，这样在函数内部修改并返回后，调用者可以拿到被修改过后的变量，也相当于一个隐式的返回值传递。

